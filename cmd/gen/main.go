package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"

	"github.com/deorth-kku/go-common"
	gocomb "github.com/mxschmitt/golang-combinations"
)

var (
	cmddir      = common.Must(os.Getwd())
	workdir     = filepath.Dir(cmddir)
	builddir    = filepath.Join(workdir, "build")
	exporterdir = filepath.Join(workdir, "exporter")
)

const repo_name = "github.com/deorth-kku/go-misc-exporter"

func find_exporters() (exporters []string) {
	for _, dir := range common.Must(os.ReadDir(exporterdir)) {
		if !dir.IsDir() {
			continue
		}
		exporters = append(exporters, dir.Name())
	}
	return
}

func main() {
	if _, err := os.Stat(builddir); os.IsNotExist(err) {
		common.Must0(os.Mkdir(builddir, 0755))
	}
	for _, comb := range gocomb.All(find_exporters()) {
		combname := strings.Join(comb, "+")
		exporterdir := filepath.Join(builddir, combname)
		dirstat, err := os.Stat(exporterdir)
		if err == nil && !dirstat.IsDir() {
			panic(exporterdir + " existed and is not a dir")
		} else if os.IsNotExist(err) {
			common.Must0(os.Mkdir(exporterdir, 0755))
		} else if err != nil {
			panic(err)
		}
		buf := new(bytes.Buffer)

		fmt.Fprintf(buf, `// Code generated by %s/cmd. DO NOT EDIT.
		package main

		import (
		"encoding/json"
		"log/slog"
		
		"%s/cmd"
		`, repo_name, repo_name)
		for _, exp := range comb {
			fmt.Fprintf(buf, `"%s/exporter/%s"
			`, repo_name, exp)
		}
		buf.WriteString("\n)\n")

		buf.WriteString(`func main(){
		rawconf,err:=cmd.InitFlags()
		if err!=nil{
			slog.Error("failed to init flags","err",err)
			return
		}
		cs:=make([]cmd.Collector,0)	
		`)
		for _, exp := range comb {
			const temp = `
			%s_conf:=%s.Conf{Path:cmd.DefaultMetricsPath}
			%s_raw,ok:=rawconf["%s"]
			if ok{
				err=json.Unmarshal(%s_raw,&%s_conf)
				if err!=nil{
					slog.Error("failed to parse conf","section","%s","err",err)
					return
				}
				%s_col,err:=%s.NewCollector(%s_conf)
				if err!=nil{
					slog.Error("failed to init collector","section","%s","err",err)
					return
				}
				cs=append(cs,%s_col)
			} else {
				slog.Info("setion not present, skipping","exporter","%s")
			}
			
			`
			count := strings.Count(temp, "%s")
			a := make([]any, count)
			for i := range count {
				a[i] = exp
			}
			fmt.Fprintf(buf, temp, a...)
		}

		buf.WriteString(`err=cmd.StartCollectors(cs...)
		slog.Info("http server exited with","err",err)
		}
		`)

		f := common.Must(os.Create(filepath.Join(exporterdir, "main.go")))
		bs, err := format.Source(buf.Bytes())
		if err != nil {
			fmt.Println(err)
			bs = buf.Bytes()
		}
		common.Must(f.Write(bs))
		common.Must0(f.Sync())
		common.Must0(f.Close())
	}
}
